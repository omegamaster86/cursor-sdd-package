<meta>
description: 要件と既存コードベース間の実装ギャップを分析
argument-hint: <feature-name:$1>
</meta>

# 実装ギャップ検証

<background_information>
- **ミッション**: 要件と既存コードベースのギャップを分析し、実装戦略を策定
- **成功基準**:
  - 既存コードベースのパターンとコンポーネントの包括的な理解
  - 不足している機能と統合課題の明確な特定
  - 複数の実行可能な実装アプローチの評価
  - 設計フェーズに必要な技術調査の特定
</background_information>

<instructions>
## コアタスク
承認済み要件と既存コードベースに基づいて、機能 **$1** の実装ギャップを分析する。

## 実行ステップ

### ステップ1: コンテキストの読み込み
- `.cursor/$1/spec.json` から言語とメタデータを読み込み
- `.cursor/$1/requirements.md` から要件を読み込み

### ステップ2: 分析ガイドラインの読み込み
- `.cursor/rules/gap-analysis.md` から包括的な分析フレームワークを読み込み

### ステップ3: ギャップ分析の実行
- gap-analysis.md フレームワークに従って徹底的な調査を実施
- Grep と Read ツールを使用して既存コードベースを分析
- 必要に応じて WebSearch/WebFetch で外部依存関係を調査
- 複数の実装アプローチ（拡張/新規/ハイブリッド）を評価
- spec.json で指定された言語で出力

### ステップ4: 分析ドキュメントの生成
- gap-analysis.md の出力ガイドラインに従って包括的なギャップ分析を作成
- トレードオフを含む複数の実行可能なオプションを提示
- さらなる調査が必要な領域にフラグを立てる

## 重要な制約
- **決定より情報**: 最終的な実装選択ではなく、分析とオプションを提供
- **複数オプション**: 適用可能な場合は代替案を提示
- **徹底的な調査**: ツールを使用して既存コードベースを深く理解
- **明示的なギャップ**: 調査や検討が必要な領域を明確にフラグ
</instructions>

## ツールガイダンス
- **最初に読み込み**: 分析前にすべてのコンテキスト（spec、rules）を読み込み
- **広範囲にGrep**: パターン、規約、統合ポイントをコードベースで検索
- **WebSearch/WebFetch**: 必要に応じて外部依存関係とベストプラクティスを調査
- **最後に書き込み**: 完全な調査後にのみ分析を生成

## 出力説明
spec.json で指定された言語で以下を出力:

1. **分析サマリー**: スコープ、課題、推奨事項の簡潔な概要（3-5項目）
2. **ドキュメントステータス**: 使用した分析アプローチの確認
3. **次のステップ**: 設計フェーズへの進め方をガイド

**フォーマット要件**:
- 明確さのためMarkdown見出しを使用
- サマリーは簡潔に（300語以内）
- 詳細分析は gap-analysis.md 出力ガイドラインに従う

## 安全性とフォールバック

### エラーシナリオ
- **要件が見つからない**: requirements.md が存在しない場合、メッセージで停止: "先に `/spec-requirements $1` を実行して要件を生成してください"
- **要件が未承認**: 要件が承認されていない場合、警告を出すが続行（ギャップ分析は要件修正に役立つ）
- **複雑な統合が不明確**: ブロックするのではなく、設計フェーズでの包括的調査のためにフラグ
- **言語が未定義**: spec.json で言語が指定されていない場合、英語（`en`）をデフォルトに

### 次のフェーズ: 設計生成

**ギャップ分析完了時**:
- ギャップ分析の洞察をレビュー
- `/spec-design $1` を実行して技術設計ドキュメントを作成
- または `/spec-design $1 -y` で要件を自動承認し直接進行

**注記**: ギャップ分析はオプションですが、ブラウンフィールドプロジェクトでは設計決定の参考として推奨。
</output>
